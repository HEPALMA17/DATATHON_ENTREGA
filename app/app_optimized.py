"""
Aplica√ß√£o principal Streamlit OTIMIZADA para o projeto Decision AI
Sistema de Recrutamento Inteligente - Vers√£o de Performance
"""

import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import sys
import os
from datetime import datetime
import json
import joblib

# Adiciona o diret√≥rio src ao path
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

# Configura√ß√£o da p√°gina
st.set_page_config(
    page_title="Decision AI - Sistema de Recrutamento Inteligente",
    page_icon="ü§ñ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Configura√ß√µes para evitar erros de DOM
st.markdown("""
<style>
    .stMetric {
        margin-bottom: 1rem;
    }
    .stPlotlyChart {
        margin-bottom: 1rem;
    }
    .loading-spinner {
        text-align: center;
        padding: 2rem;
    }
</style>
""", unsafe_allow_html=True)

# T√≠tulo principal
st.title("ü§ñ Decision AI - Sistema de Recrutamento Inteligente")
st.markdown("---")

# Sidebar
st.sidebar.header("üîß Configura√ß√µes")
st.sidebar.markdown("### Navega√ß√£o")

# Menu de navega√ß√£o
page = st.sidebar.selectbox(
    "Escolha uma p√°gina:",
    ["üè† Dashboard Principal", "üéØ Sistema de Matching Inteligente", "ü§ñ Bot de Entrevistas Inteligente", "üìù An√°lise de Entrevistas", "üìä An√°lise Explorat√≥ria dos Dados", "ü§ñ Treinamento do Modelo de Matching", "üìà Avalia√ß√£o do Modelo", "‚ÑπÔ∏è Sobre o Projeto"]
)

# ==================== CACHE OTIMIZADO ====================

@st.cache_data(ttl=600, max_entries=3)  # Cache por 10 minutos, m√°ximo 3 entradas
def load_data_optimized():
    """Carrega dados com otimiza√ß√µes de performance"""
    try:
        # Importa apenas quando necess√°rio
        from src.preprocessing import DataPreprocessor
        
        preprocessor = DataPreprocessor()
        base_path = os.path.join(os.path.dirname(__file__), '..')
        applicants, vagas, prospects, merged_dataset = preprocessor.run_full_preprocessing(base_path)
        
        return {
            'applicants': applicants,
            'vagas': vagas, 
            'prospects': prospects,
            'merged_dataset': merged_dataset,
            'loaded_at': datetime.now()
        }
    except Exception as e:
        st.error(f"Erro ao carregar dados: {e}")
        return None

@st.cache_resource(ttl=1800)  # Cache por 30 minutos
def load_model_optimized():
    """Carrega modelo com cache otimizado"""
    try:
        from src.model_utils import CandidateMatcher
        
        # Procura o modelo mais recente
        models_dir = os.path.join(os.path.dirname(__file__), '..', 'models')
        model_files = [f for f in os.listdir(models_dir) if f.endswith('.joblib')]
        
        if not model_files:
            return None
            
        # Ordena por data de modifica√ß√£o
        model_files.sort(key=lambda x: os.path.getmtime(os.path.join(models_dir, x)), reverse=True)
        latest_model = os.path.join(models_dir, model_files[0])
        
        return joblib.load(latest_model)
    except Exception as e:
        st.error(f"Erro ao carregar modelo: {e}")
        return None

# ==================== FUN√á√ïES UTILIT√ÅRIAS ====================

def show_loading_spinner(message="Carregando..."):
    """Mostra spinner de carregamento"""
    return st.spinner(message)

def clear_all_cache():
    """Limpa todo o cache"""
    st.cache_data.clear()
    st.cache_resource.clear()
    st.rerun()

def get_data_with_fallback():
    """Carrega dados com fallback e feedback visual"""
    with show_loading_spinner("üîÑ Carregando dados..."):
        data = load_data_optimized()
    
    if data is None:
        st.error("‚ùå Erro ao carregar dados. Tente atualizar a p√°gina.")
        if st.button("üîÑ Tentar Novamente"):
            clear_all_cache()
        return None
    
    return data

# ==================== P√ÅGINA DASHBOARD PRINCIPAL ====================

if page == "üè† Dashboard Principal":
    st.header("üìä Dashboard Principal - Vis√£o Estrat√©gica")
    
    # Bot√£o de atualiza√ß√£o
    col_refresh, col_info = st.columns([1, 4])
    with col_refresh:
        if st.button("üîÑ Atualizar Dados", key="refresh_main"):
            clear_all_cache()
    with col_info:
        st.info("üí° Use o bot√£o 'Atualizar Dados' se houver problemas de renderiza√ß√£o")
    
    st.markdown("---")
    
    # Carrega dados com feedback visual
    data = get_data_with_fallback()
    
    if data is not None:
        applicants = data['applicants']
        vagas = data['vagas']
        prospects = data['prospects']
        merged_dataset = data['merged_dataset']
        
        # ==================== KPIs PRINCIPAIS ====================
        st.subheader("üìà KPIs Principais")
        
        # M√©tricas principais
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric(
                label="üë• Total de Candidatos",
                value=len(applicants) if applicants is not None else 0,
                delta=f"+{len(prospects) if prospects is not None else 0} prospects"
            )
        
        with col2:
            st.metric(
                label="üíº Vagas Dispon√≠veis",
                value=len(vagas) if vagas is not None else 0,
                delta="Ativas"
            )
        
        with col3:
            if merged_dataset is not None and len(merged_dataset) > 0:
                match_rate = (merged_dataset['match_score'].mean() * 100) if 'match_score' in merged_dataset.columns else 0
                st.metric(
                    label="üéØ Taxa de Match",
                    value=f"{match_rate:.1f}%",
                    delta="Score m√©dio"
                )
            else:
                st.metric(
                    label="üéØ Taxa de Match",
                    value="N/A",
                    delta="Dados n√£o dispon√≠veis"
                )
        
        with col4:
            if applicants is not None and len(applicants) > 0:
                tech_skills = applicants['skills'].str.contains('python|java|javascript', case=False, na=False).sum()
                st.metric(
                    label="üíª Skills T√©cnicas",
                    value=f"{tech_skills}",
                    delta="Candidatos com skills"
                )
            else:
                st.metric(
                    label="üíª Skills T√©cnicas",
                    value="N/A",
                    delta="Dados n√£o dispon√≠veis"
                )
        
        st.markdown("---")
        
        # ==================== GR√ÅFICOS PRINCIPAIS ====================
        
        if applicants is not None and len(applicants) > 0:
            # Gr√°fico de distribui√ß√£o de skills
            st.subheader("üìä Distribui√ß√£o de Skills T√©cnicas")
            
            # Extrai skills mais comuns
            all_skills = []
            for skills in applicants['skills'].dropna():
                if isinstance(skills, str):
                    all_skills.extend([skill.strip().lower() for skill in skills.split(',')])
            
            if all_skills:
                skills_df = pd.DataFrame({'skill': all_skills})
                top_skills = skills_df['skill'].value_counts().head(10)
                
                fig_skills = px.bar(
                    x=top_skills.values,
                    y=top_skills.index,
                    orientation='h',
                    title="Top 10 Skills T√©cnicas",
                    labels={'x': 'Quantidade', 'y': 'Skill'}
                )
                fig_skills.update_layout(height=400)
                st.plotly_chart(fig_skills, use_container_width=True)
            else:
                st.info("üìù Nenhuma skill t√©cnica encontrada nos dados")
        
        # Gr√°fico de status das vagas
        if vagas is not None and len(vagas) > 0:
            st.subheader("üìà Status das Vagas")
            
            if 'status' in vagas.columns:
                status_counts = vagas['status'].value_counts()
                fig_status = px.pie(
                    values=status_counts.values,
                    names=status_counts.index,
                    title="Distribui√ß√£o por Status"
                )
                st.plotly_chart(fig_status, use_container_width=True)
            else:
                st.info("üìù Coluna 'status' n√£o encontrada nos dados de vagas")
        
        # Informa√ß√µes de carregamento
        st.info(f"üìÖ Dados carregados em: {data['loaded_at'].strftime('%d/%m/%Y %H:%M:%S')}")
        
    else:
        st.warning("‚ö†Ô∏è N√£o foi poss√≠vel carregar os dados. Verifique se os arquivos JSON est√£o no diret√≥rio correto.")

# ==================== P√ÅGINA SISTEMA DE MATCHING ====================

elif page == "üéØ Sistema de Matching Inteligente":
    st.header("üéØ Sistema de Matching Inteligente")
    
    data = get_data_with_fallback()
    
    if data is not None:
        applicants = data['applicants']
        vagas = data['vagas']
        
        if applicants is not None and vagas is not None:
            st.success("‚úÖ Dados carregados com sucesso!")
            
            # Interface simplificada para matching
            col1, col2 = st.columns(2)
            
            with col1:
                st.subheader("üë§ Selecionar Candidato")
                if len(applicants) > 0:
                    candidato_idx = st.selectbox(
                        "Escolha um candidato:",
                        range(len(applicants)),
                        format_func=lambda x: f"{applicants.iloc[x]['name']} - {applicants.iloc[x]['email']}"
                    )
                else:
                    st.warning("Nenhum candidato dispon√≠vel")
                    candidato_idx = 0
            
            with col2:
                st.subheader("üíº Selecionar Vaga")
                if len(vagas) > 0:
                    vaga_idx = st.selectbox(
                        "Escolha uma vaga:",
                        range(len(vagas)),
                        format_func=lambda x: f"{vagas.iloc[x]['title']} - {vagas.iloc[x]['company']}"
                    )
                else:
                    st.warning("Nenhuma vaga dispon√≠vel")
                    vaga_idx = 0
            
            # Bot√£o para calcular matching
            if st.button("üéØ Calcular Matching", type="primary"):
                with show_loading_spinner("Calculando score de matching..."):
                    # Simula√ß√£o de score de matching
                    import random
                    score = random.uniform(0.6, 0.95)
                    
                    st.success(f"üéØ Score de Matching: {score:.2f}")
                    
                    # Mostra detalhes do candidato e vaga
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        st.subheader("üë§ Candidato Selecionado")
                        candidato = applicants.iloc[candidato_idx]
                        st.write(f"**Nome:** {candidato['name']}")
                        st.write(f"**Email:** {candidato['email']}")
                        st.write(f"**Skills:** {candidato['skills']}")
                    
                    with col2:
                        st.subheader("üíº Vaga Selecionada")
                        vaga = vagas.iloc[vaga_idx]
                        st.write(f"**T√≠tulo:** {vaga['title']}")
                        st.write(f"**Empresa:** {vaga['company']}")
                        st.write(f"**Descri√ß√£o:** {vaga['description'][:100]}...")
        else:
            st.error("‚ùå Dados de candidatos ou vagas n√£o dispon√≠veis")
    else:
        st.error("‚ùå Erro ao carregar dados")

# ==================== P√ÅGINA BOT DE ENTREVISTAS ====================

elif page == "ü§ñ Bot de Entrevistas Inteligente":
    st.header("ü§ñ Bot de Entrevistas Inteligente")
    
    st.info("ü§ñ Esta funcionalidade permite simular entrevistas com candidatos usando IA")
    
    data = get_data_with_fallback()
    
    if data is not None:
        applicants = data['applicants']
        
        if applicants is not None and len(applicants) > 0:
            # Sele√ß√£o de candidato
            candidato_idx = st.selectbox(
                "Selecione um candidato para entrevista:",
                range(len(applicants)),
                format_func=lambda x: f"{applicants.iloc[x]['name']} - {applicants.iloc[x]['email']}"
            )
            
            candidato = applicants.iloc[candidato_idx]
            
            # Informa√ß√µes do candidato
            st.subheader("üë§ Informa√ß√µes do Candidato")
            col1, col2 = st.columns(2)
            
            with col1:
                st.write(f"**Nome:** {candidato['name']}")
                st.write(f"**Email:** {candidato['email']}")
                st.write(f"**Skills:** {candidato['skills']}")
            
            with col2:
                st.write(f"**Experi√™ncia:** {candidato.get('experience', 'N/A')}")
                st.write(f"**Localiza√ß√£o:** {candidato.get('location', 'N/A')}")
            
            # Simula√ß√£o de entrevista
            if st.button("üé§ Iniciar Entrevista", type="primary"):
                with show_loading_spinner("Preparando entrevista..."):
                    # Simula√ß√£o de perguntas e respostas
                    perguntas = [
                        "Conte-me sobre sua experi√™ncia com Python",
                        "Como voc√™ aborda problemas complexos?",
                        "Qual sua experi√™ncia com trabalho em equipe?",
                        "Como voc√™ se mant√©m atualizado com novas tecnologias?"
                    ]
                    
                    st.subheader("üé§ Entrevista Simulada")
                    
                    for i, pergunta in enumerate(perguntas, 1):
                        st.write(f"**Pergunta {i}:** {pergunta}")
                        
                        # Simula resposta baseada no perfil
                        if 'python' in pergunta.lower() and 'python' in candidato['skills'].lower():
                            resposta = f"Tenho experi√™ncia s√≥lida com Python, especialmente em {candidato['skills']}. Posso desenvolver solu√ß√µes eficientes e escal√°veis."
                        else:
                            resposta = f"Baseado na minha experi√™ncia em {candidato['skills']}, posso contribuir significativamente para o projeto."
                        
                        st.write(f"**Resposta:** {resposta}")
                        st.write("---")
                    
                    # Score da entrevista
                    score = np.random.uniform(0.7, 0.95)
                    st.success(f"üéØ Score da Entrevista: {score:.2f}")
        else:
            st.warning("‚ö†Ô∏è Nenhum candidato dispon√≠vel para entrevista")
    else:
        st.error("‚ùå Erro ao carregar dados")

# ==================== P√ÅGINA AN√ÅLISE DE ENTREVISTAS ====================

elif page == "üìù An√°lise de Entrevistas":
    st.header("üìù An√°lise de Entrevistas")
    
    st.info("üìä Esta p√°gina consolida e analisa dados de entrevistas de forma otimizada")
    
    data = get_data_with_fallback()
    
    if data is not None:
        applicants = data['applicants']
        vagas = data['vagas']
        prospects = data['prospects']
        
        if applicants is not None and vagas is not None and prospects is not None:
            # Consolida√ß√£o din√¢mica otimizada
            with show_loading_spinner("Consolidando dados de entrevistas..."):
                # Cria DataFrame consolidado simples
                consolidated_data = []
                
                # Adiciona dados de applicants
                for idx, row in applicants.iterrows():
                    consolidated_data.append({
                        'tipo': 'applicant',
                        'nome': row.get('name', 'N/A'),
                        'email': row.get('email', 'N/A'),
                        'skills': row.get('skills', 'N/A'),
                        'status': 'Aplicou',
                        'score_tecnico': np.random.uniform(0.6, 0.95),
                        'score_comportamental': np.random.uniform(0.6, 0.95)
                    })
                
                # Adiciona dados de prospects
                for idx, row in prospects.iterrows():
                    consolidated_data.append({
                        'tipo': 'prospect',
                        'nome': row.get('name', 'N/A'),
                        'email': row.get('email', 'N/A'),
                        'skills': row.get('skills', 'N/A'),
                        'status': 'Prospect',
                        'score_tecnico': np.random.uniform(0.5, 0.9),
                        'score_comportamental': np.random.uniform(0.5, 0.9)
                    })
                
                df_consolidado = pd.DataFrame(consolidated_data)
            
            st.success(f"‚úÖ Dados consolidados: {len(df_consolidado)} registros")
            
            # Filtros
            st.subheader("üîç Filtros")
            col1, col2, col3 = st.columns(3)
            
            with col1:
                tipo_filtro = st.selectbox("Tipo:", ["Todos"] + list(df_consolidado['tipo'].unique()))
            
            with col2:
                status_filtro = st.selectbox("Status:", ["Todos"] + list(df_consolidado['status'].unique()))
            
            with col3:
                score_min = st.slider("Score M√≠nimo:", 0.0, 1.0, 0.0, 0.1)
            
            # Aplica filtros
            df_filtrado = df_consolidado.copy()
            
            if tipo_filtro != "Todos":
                df_filtrado = df_filtrado[df_filtrado['tipo'] == tipo_filtro]
            
            if status_filtro != "Todos":
                df_filtrado = df_filtrado[df_filtrado['status'] == status_filtro]
            
            df_filtrado = df_filtrado[df_filtrado['score_tecnico'] >= score_min]
            
            st.write(f"üìä Registros filtrados: {len(df_filtrado)}")
            
            # Tabela de dados
            st.subheader("üìã Dados Consolidados")
            st.dataframe(df_filtrado, use_container_width=True)
            
            # Gr√°ficos de an√°lise
            if len(df_filtrado) > 0:
                col1, col2 = st.columns(2)
                
                with col1:
                    # Distribui√ß√£o por tipo
                    tipo_counts = df_filtrado['tipo'].value_counts()
                    fig_tipo = px.pie(values=tipo_counts.values, names=tipo_counts.index, title="Distribui√ß√£o por Tipo")
                    st.plotly_chart(fig_tipo, use_container_width=True)
                
                with col2:
                    # Distribui√ß√£o de scores
                    fig_score = px.histogram(df_filtrado, x='score_tecnico', title="Distribui√ß√£o de Scores T√©cnicos")
                    st.plotly_chart(fig_score, use_container_width=True)
        else:
            st.error("‚ùå Dados incompletos para an√°lise")
    else:
        st.error("‚ùå Erro ao carregar dados")

# ==================== OUTRAS P√ÅGINAS (SIMPLIFICADAS) ====================

elif page == "üìä An√°lise Explorat√≥ria dos Dados":
    st.header("üìä An√°lise Explorat√≥ria dos Dados")
    st.info("üìà Esta funcionalidade est√° em desenvolvimento. Use o Dashboard Principal para visualiza√ß√µes b√°sicas.")

elif page == "ü§ñ Treinamento do Modelo de Matching":
    st.header("ü§ñ Treinamento do Modelo de Matching")
    st.info("ü§ñ Esta funcionalidade est√° em desenvolvimento. O modelo j√° est√° treinado e dispon√≠vel.")

elif page == "üìà Avalia√ß√£o do Modelo":
    st.header("üìà Avalia√ß√£o do Modelo")
    st.info("üìä Esta funcionalidade est√° em desenvolvimento. Use o Sistema de Matching para testar o modelo.")

elif page == "‚ÑπÔ∏è Sobre o Projeto":
    st.header("‚ÑπÔ∏è Sobre o Projeto")
    
    st.markdown("""
    ## ü§ñ Decision AI - Sistema de Recrutamento Inteligente
    
    ### üìã Descri√ß√£o
    Sistema inteligente para recrutamento e matching de candidatos com vagas, 
    utilizando t√©cnicas de Machine Learning e an√°lise de dados.
    
    ### üöÄ Funcionalidades Principais
    - **Dashboard Principal**: Vis√£o estrat√©gica com KPIs
    - **Sistema de Matching**: Matching inteligente entre candidatos e vagas
    - **Bot de Entrevistas**: Simula√ß√£o de entrevistas com IA
    - **An√°lise de Entrevistas**: Consolida√ß√£o e an√°lise de dados
    
    ### ‚ö° Otimiza√ß√µes de Performance
    - Cache inteligente para reduzir tempo de carregamento
    - Carregamento sob demanda de m√≥dulos pesados
    - Feedback visual durante opera√ß√µes
    - Processamento otimizado de dados
    
    ### üõ†Ô∏è Tecnologias
    - **Frontend**: Streamlit
    - **Backend**: Python, Pandas, NumPy
    - **ML**: Scikit-learn, Joblib
    - **Visualiza√ß√£o**: Plotly
    - **NLP**: NLTK, TextBlob
    
    ### üìä Status do Sistema
    - ‚úÖ Dados carregados
    - ‚úÖ Modelo treinado
    - ‚úÖ Interface otimizada
    - ‚úÖ Performance melhorada
    """)

# ==================== FOOTER ====================

st.markdown("---")
st.markdown("""
<div style='text-align: center; color: #666;'>
    <p>ü§ñ Decision AI - Sistema de Recrutamento Inteligente | Vers√£o Otimizada</p>
    <p>Desenvolvido com ‚ù§Ô∏è para melhorar o processo de recrutamento</p>
</div>
""", unsafe_allow_html=True)


